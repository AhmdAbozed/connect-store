var g=Object.defineProperty;var h=(l,n,s)=>n in l?g(l,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):l[n]=s;var o=(l,n,s)=>h(l,typeof n!="symbol"?n+"":n,s);const d=(l,n)=>{const s=l.map(e=>({filterName:e,filterChildren:[]}));return n.forEach(e=>{JSON.parse(e.specifications).forEach(t=>{const i=s.find(c=>c.filterName==t.specName);if(i){const c=i.filterChildren.find(p=>p.value==t.specValue);c?c.productCount+=1:i.filterChildren.push({value:t.specValue,productCount:1})}})}),s};class m{static getSpecsString(n){let s="";return JSON.parse(n.specifications).forEach(e=>{s+=e.specValue+"  "}),s}static filterRecorders(n,s){const e=[];return n.forEach(a=>{var i,c;const t=this.getSpecsString(a);if((i=s.cameras)!=null&&i.length){const p=s.cameras.find(r=>r.type=="Analog"&&a.type=="NVR"||r.type=="IP"&&a.type=="DVR"),u=s.cameras.find(r=>r.resolutionInMP>a.resolutionInMP);if(p){e.push({item:a,specs:t,compatibility:!1,message:"Incompatible type with: "+p.name});return}else if(a.channels<((c=s.cameras)==null?void 0:c.length)){e.push({item:a,specs:t,compatibility:!1,message:"Not enough camera channels"});return}else if(u){e.push({item:a,specs:t,compatibility:!1,message:"Incompatible resolution with: "+u.name});return}else{e.push({item:a,specs:t,compatibility:!0,message:null});return}}else{e.push({item:a,specs:t,compatibility:!0,message:null});return}}),e}static filterCameras(n,s){const e=[];let a=0;return s.cameras.forEach(t=>{a+=t.amp}),n.forEach(t=>{var c,p,u;const i=this.getSpecsString(t);if(s.recorder[0]){if(((c=s.cameras)==null?void 0:c.length)>=s.recorder[0].channels){e.push({item:t,specs:i,compatibility:!1,message:"Not enough camera channels in recorder"});return}else if(t.type=="Analog"&&s.recorder[0].type=="NVR"||t.type=="IP"&&s.recorder[0].type=="DVR"){e.push({item:t,specs:i,compatibility:!1,message:"Incompatible type with recorder"});return}else if(t.resolutionInMP>s.recorder[0].resolutionInMP){e.push({item:t,specs:i,compatibility:!1,message:"Incompatible resolution with recorder"});return}}if(s.PDU[0]){if(t.voltage!=((p=s.PDU[0])==null?void 0:p.voltage)){e.push({item:t,specs:i,compatibility:!1,message:"Incompatible voltage with PDU"});return}else if(a+t.amp>((u=s.PDU[0])==null?void 0:u.amp)){e.push({item:t,specs:i,compatibility:!1,message:"Not enough Amps in PDU for more cameras"});return}}if(s.cables.length){const r=s.cables.find(f=>t.type=="Analog"&&f.type=="Ethernet"||t.type=="IP"&&f.type=="Coaxial");if(r){e.push({item:t,specs:i,compatibility:!1,message:"Incompatible type with cable: "+r.name});return}}if(s.cameras.length==8){e.push({item:t,specs:i,compatibility:!1,message:"Max 8 cameras"});return}e.push({item:t,specs:i,compatibility:!0,message:null})}),e}static filterPDUs(n,s){const e=[];let a=0;return s.cameras.forEach(t=>{a+=t.amp}),n.forEach(t=>{const i=this.getSpecsString(t);if(s.cameras.length){const c=s.cameras.find(p=>p.voltage!=t.voltage);if(c){e.push({item:t,specs:i,compatibility:!1,message:"Incompatible voltage with: "+c.name});return}else if(a>t.amp){e.push({item:t,specs:i,compatibility:!1,message:"Not enough Amps. "+a+"A Needed"});return}}e.push({item:t,specs:i,compatibility:!0,message:null})}),e}static filterCables(n,s){const e=[];return n.forEach(a=>{const t=this.getSpecsString(a);if(s.cameras.length){const i=s.cameras.find(c=>c.type=="Analog"&&a.type=="Ethernet"||c.type=="IP"&&a.type=="Coaxial");if(i){e.push({item:a,specs:t,compatibility:!1,message:"Incompatible type with: "+i.name});return}}if(s.cables.length==8){e.push({item:a,specs:t,compatibility:!1,message:"Max 8 cables"});return}e.push({item:a,specs:t,compatibility:!0,message:null})}),e}}o(m,"recordersId",1),o(m,"camerasId",2),o(m,"PDUsId",3),o(m,"CablesId",4),o(m,"accessoriesId",5);class N{static mapRecorders(n){return Object.values(n).map(e=>{const a=Number(JSON.parse(e.specifications).find(c=>c.specName=="Channels").specValue.replace(/\D/g,"")),t=Number(JSON.parse(e.specifications).find(c=>c.specName=="Resolution").specValue.replace(/\D/g,""));let i=JSON.parse(e.specifications).find(c=>c.specName=="Type").specValue;return i=i.slice(0,e.subcategory.name.length-1),{type:i,channels:a,resolutionInMP:t,...e}})}static mapCameras(n){console.log("filtring",n);const s=Object.values(n).map(e=>{const a=Number(JSON.parse(e.specifications).find(p=>p.specName=="Voltage").specValue.replace(/\D/g,"")),t=Number(JSON.parse(e.specifications).find(p=>p.specName=="Wattage").specValue.replace(/\D/g,"")),i=Number(JSON.parse(e.specifications).find(p=>p.specName=="Resolution").specValue.replace(/\D/g,""));let c=JSON.parse(e.specifications).find(p=>p.specName=="Type").specValue;return c=c.slice(0,e.subcategory.name.length-1),{type:c,voltage:a,amp:t/a,resolutionInMP:i,...e}});return console.log(s),s}static mapPDUs(n){return Object.values(n).map(e=>{const a=Number(JSON.parse(e.specifications).find(i=>i.specName=="Voltage").specValue.replace(/\D/g,"")),t=Number(JSON.parse(e.specifications).find(i=>i.specName=="Wattage").specValue.replace(/\D/g,""));return{voltage:a,amp:t/a,...e}})}static mapCables(n){return Object.values(n).map(e=>({type:JSON.parse(e.specifications).find(t=>t.specName=="Type").specValue,...e}))}}export{d as g,N as m,m as s};
