var h=Object.defineProperty;var g=(p,i,s)=>i in p?h(p,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):p[i]=s;var o=(p,i,s)=>g(p,typeof i!="symbol"?i+"":i,s);const d=(p,i)=>{const s=p.map(e=>({filterName:e,filterChildren:[]}));return i.forEach(e=>{JSON.parse(e.specifications).forEach(t=>{const n=s.find(c=>c.filterName==t.specName);if(n){const c=n.filterChildren.find(l=>l.value==t.specValue);c?c.productCount+=1:n.filterChildren.push({value:t.specValue,productCount:1})}})}),s};class m{static getSpecsString(i){let s="";return JSON.parse(i.specifications).forEach(e=>{s+=e.specValue+"  "}),s}static filterRecorders(i,s){const e=[];return i.forEach(a=>{var n,c;const t=this.getSpecsString(a);if((n=s.cameras)!=null&&n.length){const l=s.cameras.find(u=>u.type=="Analog"&&a.type=="NVR"||u.type=="IP"&&a.type=="DVR"),r=s.cameras.find(u=>u.resolutionInMP>a.resolutionInMP);if(l){e.push({item:a,specs:t,compatibility:!1,message:"Incompatible type with: "+l.name});return}else if(a.channels<((c=s.cameras)==null?void 0:c.length)){e.push({item:a,specs:t,compatibility:!1,message:"Not enough camera channels"});return}else if(r){e.push({item:a,specs:t,compatibility:!1,message:"Incompatible resolution with: "+r.name});return}else{e.push({item:a,specs:t,compatibility:!0,message:null});return}}else{e.push({item:a,specs:t,compatibility:!0,message:null});return}}),e}static filterCameras(i,s){const e=[];let a=0;return s.cameras.forEach(t=>{a+=t.amp}),i.forEach(t=>{var c;const n=this.getSpecsString(t);if(s.recorder[0]){if(((c=s.cameras)==null?void 0:c.length)>=s.recorder[0].channels){e.push({item:t,specs:n,compatibility:!1,message:"Not enough camera channels in recorder"});return}else if(t.type=="Analog"&&s.recorder[0].type=="NVR"||t.type=="IP"&&s.recorder[0].type=="DVR"){e.push({item:t,specs:n,compatibility:!1,message:"Incompatible type with recorder"});return}else if(t.resolutionInMP>s.recorder[0].resolutionInMP){e.push({item:t,specs:n,compatibility:!1,message:"Incompatible resolution with recorder"});return}}if(s.cables.length){const l=s.cables.find(r=>t.type=="Analog"&&r.type=="Ethernet"||t.type=="IP"&&r.type=="Coaxial");if(l){e.push({item:t,specs:n,compatibility:!1,message:"Incompatible type with cable: "+l.name});return}}if(s.cameras.length==8){e.push({item:t,specs:n,compatibility:!1,message:"Max 8 cameras"});return}e.push({item:t,specs:n,compatibility:!0,message:null})}),e}static filterCables(i,s){const e=[];return i.forEach(a=>{const t=this.getSpecsString(a);if(s.cameras.length){const n=s.cameras.find(c=>c.type=="Analog"&&a.type=="Ethernet"||c.type=="IP"&&a.type=="Coaxial");if(n){e.push({item:a,specs:t,compatibility:!1,message:"Incompatible type with: "+n.name});return}}if(s.cables.length==8){e.push({item:a,specs:t,compatibility:!1,message:"Max 8 cables"});return}e.push({item:a,specs:t,compatibility:!0,message:null})}),e}static noFilters(i,s){const e=[];return i.forEach(a=>{const t=this.getSpecsString(a);e.push({item:a,specs:t,compatibility:!0,message:null})}),e}}o(m,"recorderName","Video Recorders"),o(m,"cameraName","Security Cameras"),o(m,"PDUName","Power Supplies"),o(m,"cableName","Camera Cables"),o(m,"accName","Surveillance Equipment"),o(m,"monitorName","Monitors"),o(m,"hddName","Hard Drives"),o(m,"switchesName","Network Switches");class y{static mapRecorders(i){return Object.values(i).map(e=>{const a=JSON.parse(e.specifications),t=a.find(f=>f.specName==="Channel Number"),n=a.find(f=>f.specName==="Resolution"),c=a.find(f=>f.specName==="Type");if(!t||!n||!c)return null;const l=Number(t.specValue.replace(/\D/g,"")),r=Number(n.specValue.replace(/\D/g,""));let u=c.specValue;return u=u.slice(0,e.subcategory.name.length-1),{type:u,channels:l,resolutionInMP:r,...e}}).filter(e=>e!==null)}static mapCameras(i){return Object.values(i).map(e=>{const a=JSON.parse(e.specifications),t=a.find(r=>r.specName==="Resolution"),n=a.find(r=>r.specName==="Camera Types");if(!t||!n)return null;const c=Number(t.specValue.replace(/\D/g,""));let l=n.specValue;return l=l.slice(0,e.subcategory.name.length-1),{type:l,resolutionInMP:c,...e}}).filter(e=>e!==null)}static mapCables(i){return Object.values(i).map(e=>{const t=JSON.parse(e.specifications).find(c=>c.specName==="Cable Type");return t?{type:t.specValue,...e}:null}).filter(e=>e!==null)}}export{d as g,y as m,m as s};
